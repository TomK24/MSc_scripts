#!/usr/bin/python3
#########################################################################################
#Script created by Thomas Kenyon, 2020

#This script will generate a report.txt file listing the MW, HB, binding energy, COM distance, number of atoms and list H bonding residues for each .pdbqt file which has been generated by the MGLTools virtual_screening analysis script. It requires the name of the directory of the .pdbqt files and the .txt file containing COM distances and ligand names. txt file must be in same directory as script. It also has two optional criteria that allows for the selection of poses/ligands, see details below.Regardless of whether optional arguments are supplied, the report.txt file will always be the same. Only difference is that if --c is supplied it will be placed into a folder labled as the criteria list with passing ligands, if no criteria is supplied. It will be put in working directory of script.
########################################################################################
import argparse
import os
import re
from decimal import Decimal

def getMW(atoms): #Will not return correct MW as ligand does not have explicit hydrogens.
    totmass = 0.00
    for atom in atoms:
        if atom == "H":
            totmass += 1.00784
        elif atom == "C":
            totmass += 12.0107
        elif atom == "N":
            totmass += 14.0067
        elif atom == "O":
            totmass += 15.999
        elif atom == "CL":
            totmass += 35.453
        elif atom == "BR":
            totmass += 79.904
        elif atom == "I":
            totmass += 126.90447
        elif atom == "P":
            totmass += 309.73762
        elif atom == "S":
            totmass += 32.065
        elif atom == "F":
            totmass += 18.998403
        else: #This logic is very messy. But it does work
            #print(atom)
            trunc2 = atom[0]
            trunc = ""
            if len(atom) == 3 and atom[1] == "D" and atom[2].isdigit():
                trunc =atom[0]
            elif len(atom) == 3 and atom[1] == "E" and atom[2].isdigit():
                trunc =atom[0]
            elif len(atom) == 3 and atom[1].isdigit() and atom[2].isdigit():
                trunc = atom[0]
            elif len(atom) == 3 and not atom[1].isdigit() and atom[2].isdigit():
                trunc = atom[0] + atom[1]
            else:
                trunc = trunc2
            if trunc == "H":
                totmass += 1.00784
            elif trunc == "C":
                totmass += 12.0107
            elif trunc == "N":
                totmass += 14.0067
            elif trunc == "O":
                totmass += 15.999
            elif trunc == "CL":
                totmass += 35.453
            elif trunc == "BR":
                totmass += 79.904
            elif trunc == "I":
                totmass += 126.90447
            elif trunc == "P":
                totmass += 309.73762
            elif trunc == "S":
                totmass += 32.065
            elif trunc == "F":
                totmass += 18.998403
            else:
                print("ERROR! I dont know what {atom} is".format(**locals()))
    return totmass

def getAtoms(pdbqt): #list of pdbqt lines
    atoms = []
    for line in pdbqt:
        if "HETATM" in line:
            # print(line)
            new = (line[12] + line[13] + line[14] + line[15]).strip()
            new2 = new.upper()
            # print(new2)
            atoms += [new2]
    return atoms

def countAtoms(pdbqt): #list of pdbqt lines
    atoms = 0
    for line in pdbqt:
        if "HETATM" in line:
            atoms += 1
    return atoms

def countHB_old(pdbqt): # Working I think :) This counts number of actual H bonds not the number of lig atoms that are H bonding. There is a difference for some ligands but not sure how important it is.
    count = 0
    in_lig_hb_atoms = False
    for idx in range(len(pdbqt)):
        line = pdbqt[idx]
        if "lig_hb_atoms" in line:
            in_lig_hb_atoms = True
        elif in_lig_hb_atoms == True and not "lig_hb_atoms" in line and not "macro_close_ats" in line:
            count += 1
        elif "macro_close_ats" in line:
            break
    return count
#Hmmm maybe can output both this result and #hbonds in general?
def countHB_2(pdbqt, residues): # method to count H bonds to SPECIFIC residues. works as above mostly
    count = 0
    res = ""
    in_lig_hb_atoms = False
    for idx in range(len(pdbqt)):
        line = pdbqt[idx]
        if "lig_hb_atoms" in line:
            in_lig_hb_atoms = True
        elif in_lig_hb_atoms == True and not "lig_hb_atoms" in line and not "macro_close_ats" in line:
            for i in residues:
                if i in line:
                    count += 1
                    res += (i + ",")
        elif "macro_close_ats" in line:
            break
    return [count, res]

def countHB_3(pdbqt, residues): # This method extracts ALL residues H bonding not just supplied.
    extract_residue = re.compile(r"(A|B|C|D|E|F):[A-z]{3}[0-9]{1,4}:") #Works with up to 6 chains
    #will extract something like 'A:HID137:' but also A:HOH220: because HOH220 belongs to chain A too. Should I check for additives like DMSO too?
    count = 0
    count_all = 0
    res = "" #List of 
    in_lig_hb_atoms = False
    found_residues = []
    for idx in range(len(pdbqt)):
        line = pdbqt[idx]
        if "lig_hb_atoms" in line:
            in_lig_hb_atoms = True
        elif in_lig_hb_atoms == True and not "lig_hb_atoms" in line and not "macro_close_ats" in line:
            potential = re.search(extract_residue, line)
            if not potential is None:
                potential_2 = potential.group()
                residue_2 = potential_2[2:]
                residue = residue_2[:-1]
                if not "HOH" in residue and not "UNK" in residue and not "LIG" in residue:
                    #Should include other potential additives like DMSO maybe?
                    found_residues += [residue]
                    res += (residue + ",")
                    count_all +=1
                    if residue in residues:
                        count += 1
        elif "macro_close_ats" in line:
            break
    return [count, res, found_residues, count_all]


def countHB(pdbqt): #Gets directly from line 2. Not sure if 100% correct all the time. Assume this counts ligand atoms that are H bonding onto receptor. What happens if an atom has 2 H bonds? Assuming it still counts one?
    count = 0
    line = pdbqt[1]
    stripped = line.strip()
    count = stripped[len(stripped)-1] 
    return count

def getE(pdbqt, x): #x for type. Either "le" or "lc" or "vs"
    for line in range(len(pdbqt)):
        if "USER  AD> rmsd, LE" in pdbqt[line] and x == "le":
            e_line = pdbqt[line + 1]
            e_split = e_line.split(",")
            e_value = e_split[1]
            return e_value
        elif "USER  AD> rmsd, LE" in pdbqt[line] and x == "lc":
            idx = line + 1
            LC_LE = []
            clu_size = []
            while pdbqt[idx].startswith("USER  AD>"):
                e_line = pdbqt[idx]
                e_split = e_line.split(",")
                LC_LE += [float(e_split[1])]
                clu_size += [float(e_split[2])]
                idx += 1
            largest_clu = 0
            e_value = 0
            for i in range(len(LC_LE)):
                if clu_size[i] > largest_clu:
                    largest_clu = clu_size[i]
                    e_value = LC_LE[i]
            return e_value
        elif "USER  AD> rmsd, LE" in pdbqt[line] and x == "vs":
            e_line = pdbqt[line + 1]
            e_split = e_line.split(",")
            e_value = e_split[1]
            return e_value
        
#TO DO: Make another report.txt file that just lists the ligands that pass all criteria. Perhaps include an optional command to rank ligands by chosen criteria. Default can just be COM distance. \nALSO: perhaps make criteria optional incase user just wants report.\n ALSO: identify ligands with notable groups eg halogens. Maybe filter based on these groups or print them out in report.\nALSO: error resilience, script shouldn't crash if there is a pdbqt file that isnt formatted correctly. Perhaps enclose logic in try statements so that problematic ligands can be listed and identified easily.        

parser = argparse.ArgumentParser(description="This script will generate a report.txt file listing the MW, HB, binding energy, COM distance, number of atoms and list H bonding residues for each .pdbqt file which has been generated by the MGLTools virtual_screening analysis script. It requires the name of the directory of the .pdbqt files and the .txt file containing COM distances and ligand names. txt file must be in same directory as script. It also has two optional criteria that allows for the selection of poses/ligands, see details below.Regardless of whether optional arguments are supplied, the report.txt file will always be the same. Only difference is that if --c is supplied it will be placed into a folder labled as the criteria list with passing ligands, if no criteria is supplied. It will be put in working directory of script.")

parser.add_argument("--d", required= True, type= str, help="Name of directory with all.pdbqt files")
parser.add_argument("--r", required= True, type= str, help="COM distances txt file. Unsorted or sorted works.")
parser.add_argument("--c", required= False, type= str, help="OPTIONAL. List of criteria used for selection, eg: '--c 10,2,-8,100,500'(where each number represents COM distance, number of H bonds, binding energy, number of atoms and molecular mass respectively). Conditionals are inclusive, specifying a COM distance of '10' will mean ligands with a COM distance of 10.00 will pass but 10.01 will not. PDBQT files that pass all these criteria will be moved into a folder labled as the criteria list. NBNBNBNB BEWARE the MW criteria is incorrect as this script cannot count implicit hydrogens!")
parser.add_argument("--a", required= False, type= str, help="OPTIONAL. List of specific residues that you want to check for H bonding. The final value is an integer that is the minimum  number of H bonds that must occur between the ligand and the specific residues you list. Eg 'ASP8,CYS138,1' means 2 specific residues and the ligand must be H bonding to at least one of them. NOTE, this criteria is linked to the other non-specific H bond criteria. If criteria for non-specific H-bonds is 3 and the criteria 'ASP8,CYS138,2' is met, ligand will only pass if there is at least one more H bond. Conversly, if 'ASP8,CYS138,2' is supplied but ligand is not H bonding to both, the ligand will fail, even if it passes the non-specific H bond test. You can also use this criteria as an alternative to COM distance selection (especially useful if your COM script was not great like ours was), ligands H-bonding to 1 or more residues in a region will likely be in the same region as active site provided they are not excessively large molecules NB: be careful with formatting here, script will not look for or try fix any errors.'ASP8CYS321' will definitely cause a crash.")
args = parser.parse_args() 
folder_name = args.d
com_name = args.r
critera_usr = ""
crit_specified = False
if args.c:
    crit_specified = True
critera_usr = args.c 
aas_usr = ""
aas2 = []
aas_list = []
aas3 = ""
aas4 = ""
aas_specified = False
c_spec_hb = 0
#*******MORE DEBUG CODE************
# aas_usr = "ASP8,CYS138,ALA134,ILE133,1"
# aas4 = aas_usr[:-2]
# aas2 = aas_usr.split(",")
# aas_list = aas2[:-1]
# aas3 = aas_usr[:-1]
# c_spec_hb = int(aas2[len(aas2)-1])
# aas = aas2[:-1]
# aas_specified = True
#**********************
try: #This try statement is used to handle the optional argument but it is actually far simpler to just use an if statment:
    # if args.a:
    aas_usr = args.a
    aas2 = aas_usr.split(",")
    aas_list = aas2[:-1]
    aas3 = aas_usr[:-1]
    aas4 = aas_usr[:-2]
    c_spec_hb = int(aas2[len(aas2)-1])
    aas = aas2[:-1]
    aas_specified = True
    print("Specific residues listed")
except:
    print("No specific residues specified OR supplied in incorrect format.. Counting all H bonds...")
#aas_usr = args.a
#aas = aas_usr.split(",")
if aas_specified == True and crit_specified == False:
    print("If --a argument is supplied, --c must be too. If you're not interested in a particular property, just make its value excessively large or small.")
    quit()
#****************************************************DEBUG CODE***********************************************
# folder_name = "output"
# com_name = "COM_sorted.txt"
# critera_usr = "100,1,-1,100,5000"
#*************************************************************************************************************
criteria_list = [0,0,0,0,0]
if crit_specified == True:
    criteria_list = critera_usr.split(",")
if not len(criteria_list) == 5:
    print("Error: incorrect criteria inputted. \nCorrect format is:\n'--c 10,2,-8,100,500'(COM distance, number of H bonds, binding energy, number of atoms and molecular mass respectively). Conditionals are inclusive, specifying a COM distance of '10' will mean ligands with a COM distance of 10 will pass but a COM distance of 10.01 will not.\nPlease try again")
    quit()
c_com = float(criteria_list[0])
c_hb = int(criteria_list[1])
c_e = float(criteria_list[2])
c_a = int(criteria_list[3])
c_mw = float(criteria_list[4])
if crit_specified == True:
    os.system("mkdir {critera_usr}".format(**locals()))
#files = os.listdir("./{folder_name}".format(**locals()))
new_file = []
pass_new_file = []
com = open(com_name, "r")
com_lines = com.readlines()
com.close()
list_ligs = []
count_processed = 0
count_passed = 0
file_errors = 0
file_error_list = []
#for filename in files: #I think its best to go through the COM list file and open each pdbqt from there. For each one open it and get name, COM distance, energy, hbs, MW and #atoms 
#*************************************LOGIC*******************************************
for line in com_lines: # For each line (ligand) in the COM distance txt file, parse COM distance and all relevant info for selection from corresponding pdbqt file in output folder
    #print(line)
    if not ".pdbqt" in line or line == "" or line == "\n":
        print("There is something wrong with the line:\n{line}\nIgnoring it.format".format(**locals()))
        continue
    temp = line.split()
    name = temp[0]
    dist = temp[1]
    dist2 = Decimal(float(dist))
    dist3 = round(dist2, 2)
    energy = 0.0
    hbs = 0
    hbs2 = 0
    mass = 0.0
    num_atoms = 0
    pdbqt =[]
    pdbqts = []
    pdbqts = os.listdir("./{folder_name}".format(**locals()))
    if name in pdbqts: #If pdbqt file named in COM distance txt file is also present in output file
        pdbqt_file = open("./{folder_name}/{name}".format(**locals()))
        pdbqt = pdbqt_file.readlines()
        pdbqt_file.close()
    else:               #If it isn't, ignore it and carry on to next ligand but note the file name and add to error report. count number of errors too
        print("The file {name} not found in folder {folder_name}".format(**locals()))
        file_errors +=1
        file_error_list += [name]
        continue
    #Get energy
    if name.endswith("le.pdbqt"):
        energy = getE(pdbqt, "le")
    elif name.endswith("lc.pdbqt"):
        energy = getE(pdbqt, "lc")
    elif name.endswith("vs.pdbqt"):
        energy = getE(pdbqt, "vs")
    energy2 = Decimal(float(energy))
    energy3 = round(energy2, 2)
    #Get hbs
    # hbs = countHB_old(pdbqt)
    hbs2_pre = [] # Specific H bonds count
    hbs2 = 0
    hbs2_list =""
    # if aas_specified == True:
    #     hbs2_pre = countHB_2(pdbqt, aas_list) # Specific H bonds count
    #     hbs2 = int(hbs2_pre[0])
    #     hbs2_list = (hbs2_pre[1])[:-1]
    if aas_specified == True:
        hbs2_pre = countHB_3(pdbqt, aas_list) # Specific H bonds count
        hbs2 = int(hbs2_pre[0])
        hbs2_list = (hbs2_pre[1])[:-1]
    else:
        hbs2_pre = countHB_3(pdbqt, ["ASP8"]) # Dummy list to keep method happy
        hbs2 = int(hbs2_pre[0]) # count value used in if statements below
        hbs2_list = (hbs2_pre[1])[:-1]
    hbs = hbs2_pre[3]
    atom_list = getAtoms(pdbqt)
    num_atoms = len(atom_list)
    mass = getMW(atom_list)
    mass2 = Decimal(float(mass))
    mass3 = round(mass2, 2)
    spacing = []
    sep = ""
    passed = False
    if float(dist) <= c_com and int(hbs) >= c_hb and float(energy) <= c_e and num_atoms <= c_a and mass <= c_mw and aas_specified == False and crit_specified == True: #If no specific residues supplied
        # os.chdir("./selection")
        os.system("cp ./{folder_name}/{name} -t ./{critera_usr}".format(**locals()))
        list_ligs += [name + "\n"]
        count_passed += 1
        passed = True
    elif float(dist) <= c_com and int(hbs) >= c_hb and float(energy) <= c_e and num_atoms <= c_a and mass <= c_mw and aas_specified == True and hbs2 >= c_spec_hb and crit_specified == True: # specific residues supplied so considering number of those.
        # os.chdir("./selection")
        os.system("cp ./{folder_name}/{name} -t ./{critera_usr}".format(**locals()))
        list_ligs += [name + "\n"]
        count_passed += 1
        passed = True
    elif crit_specified == False:
        list_ligs += [name + "\n"]
    while not (len(name) + len(spacing)) == 23:
        spacing += [" "]
    padded_name = name + sep.join(spacing)
    #This is not a good way to layout results. Should construct report by taking into accound length of all entries so everything is evenly spaced no matter length of ligand name etc etc.
    # if aas_specified == False:
    #     new_line = "{padded_name}  {dist3}   {hbs}    {energy3}    {num_atoms}  {mass3} \n".format(**locals())
    #     new_file += [new_line]
    #     count_processed +=1
    # else:
    #     new_line = "{padded_name}  {dist3}   {hbs}    {energy3}    {num_atoms}  {mass3}   {hbs2_list}\n".format(**locals())
    #     new_file += [new_line]
    #     count_processed +=1
    new_line = "{padded_name}  {dist3}   {hbs}    {energy3}    {num_atoms}  {mass3}   {hbs2_list}\n".format(**locals())
    new_file += [new_line]
    if passed == True:
        pass_new_file += [new_line]
    count_processed +=1
new = None
passed_new = None
new2 = None
if crit_specified == True:
    new = open("./{critera_usr}/report_all.txt".format(**locals()), "w")
    passed_new = open("./{critera_usr}/report.txt".format(**locals()), "w")
    new2 = open("./{critera_usr}/list.txt".format(**locals()), "w")
else:
    new = open("./report_all.txt".format(**locals()), "w")
    passed_new = open("./report.txt".format(**locals()), "w")
    new2 = open("list.txt".format(**locals()), "w")
#
# LOL I dont think below if statements are neccessary actually as report.txt looks the same no matter what? 
# Report stays same no matter what, its just the report for ligands that passed which isnt created if no criteria are supplied
if crit_specified == False:
    new_file2 = []
    #new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW \n"]
    new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW   Specific residues\n"]
    #new_file2 += ["---------------------------------------------------------\n"]
    new_file2 += ["--------------------------------------------------------------------------\n"]
    new.writelines(new_file2)
    new.writelines(new_file)
    new.close()
    #passed_new_file2 = []
    #passed_new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW   Specific residues\n"]
    #passed_new_file2 += ["--------------------------------------------------------------------------\n"]
    #passed_new.writelines(passed_new_file2)
    #passed_new.writelines(pass_new_file)
    #passed_new.close()
    # new2 = open("list.txt", "w")
    new2.writelines(list_ligs)
    new2.close()
    print("No Criteria specified, just generating report.txt file for pdbqts in /{folder_name}.".format(**locals()))
    print("{count_processed} pdbqt files processed".format(**locals()))
    #print("{count_passed} dockings passed all criteria listed below:\n COM Distance:       {c_com}\n # HBs:              {c_hb}\n Binding energy:    {c_e}\n Number of atoms: {c_a}\n MW:               {c_mw}".format(**locals()))
    if file_errors > 0:
        print("{file_errors} reported. There are files listed in your COM list file that arent in the folder you specified. See them below:")
        for i in file_error_list:
            print(i)
elif aas_specified == False:
    new_file2 = []
    #new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW \n"]
    new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW   Specific residues\n"]
    #new_file2 += ["---------------------------------------------------------\n"]
    new_file2 += ["--------------------------------------------------------------------------\n"]
    new.writelines(new_file2)
    new.writelines(new_file)
    new.close()
    passed_new_file2 = []
    passed_new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW   Specific residues\n"]
    passed_new_file2 += ["--------------------------------------------------------------------------\n"]
    passed_new.writelines(passed_new_file2)
    passed_new.writelines(pass_new_file)
    passed_new.close()
    # new2 = open("list.txt", "w")
    new2.writelines(list_ligs)
    new2.close()
    print("{count_processed} pdbqt files processed".format(**locals()))
    print("{count_passed} dockings passed all criteria listed below:\n COM Distance:       <= {c_com}\n # HBs:              >= {c_hb}\n Binding energy:     <= {c_e}\n Number of atoms:    <= {c_a}\n MW:                 <= {c_mw}".format(**locals()))
    if file_errors > 0:
        print("{file_errors} reported. There are files listed in your COM list file that arent in the folder you specified. See them below:")
        for i in file_error_list:
            print(i)
elif aas_specified == True:
    new_file2 = []
    new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW   Specific residues\n"]
    new_file2 += ["--------------------------------------------------------------------------\n"]
    new.writelines(new_file2)
    new.writelines(new_file)
    new.close()
    passed_new_file2 = []
    passed_new_file2 += ["Name                     COM  #HBs  Energy #atoms   MW   Specific residues\n"]
    passed_new_file2 += ["--------------------------------------------------------------------------\n"]
    passed_new.writelines(passed_new_file2)
    passed_new.writelines(pass_new_file)
    passed_new.close()
    #new2 = open("list.txt", "w")
    new2.writelines(list_ligs)
    new2.close()
    print("{count_processed} pdbqt files processed".format(**locals()))
    
    print("{count_passed} dockings passed all criteria listed below:\n COM Distance:       <= {c_com}\n # HBs:              >= {c_hb}\n Binding energy:     <= {c_e}\n Number of atoms:    <= {c_a}\n MW:                 <= {c_mw}\nSpecific H-bonding residues: {aas4}\n       -minimim of {c_spec_hb} required to pass".format(**locals()))
    if file_errors > 0:
        print("{file_errors} reported. There are files listed in your COM list file that arent in the folder you specified. See them below:")
        for i in file_error_list:
            print(i)

#*************************************************************************************
print("Reminder: filtering by MW with this script will lead to incorrect results as this script cannot detect implicit hydrogens for the MW calculation! (thanks prudence for letting me know!) Rather filter beforehand and then pass this script a very high MW.")
print("done!")
quit()
